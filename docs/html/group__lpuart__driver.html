<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Reinforcement Learning based Illumination Controller (RLIC): Lpuart_driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Reinforcement Learning based Illumination Controller (RLIC)
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Lpuart_driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__lpuart__config.html">_lpuart_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART configuration structure.  <a href="struct__lpuart__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__lpuart__transfer.html">_lpuart_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART transfer structure.  <a href="struct__lpuart__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__lpuart__handle.html">_lpuart_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART handle structure.  <a href="struct__lpuart__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae83107a96ce0e34e791aac795a4d04e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae83107a96ce0e34e791aac795a4d04e4">_lpuart_config::baudRate_Bps</a></td></tr>
<tr class="separator:gae83107a96ce0e34e791aac795a4d04e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4571e45bcd0dc5e23ef6c9491f415636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lpuart__driver.html#gaade003e399c40357cf787b87e39083a1">lpuart_parity_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga4571e45bcd0dc5e23ef6c9491f415636">_lpuart_config::parityMode</a></td></tr>
<tr class="separator:ga4571e45bcd0dc5e23ef6c9491f415636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78b1ec3d4ad983717c0ddb6fc90a7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lpuart__driver.html#ga6785b5dcafe473d18fd40d490251c5eb">lpuart_data_bits_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaf78b1ec3d4ad983717c0ddb6fc90a7c3">_lpuart_config::dataBitsCount</a></td></tr>
<tr class="separator:gaf78b1ec3d4ad983717c0ddb6fc90a7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b1bc6d9fd6be7a792e3f06ef9801ceb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga0b1bc6d9fd6be7a792e3f06ef9801ceb">_lpuart_config::isMsb</a></td></tr>
<tr class="separator:ga0b1bc6d9fd6be7a792e3f06ef9801ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ac9d819675f5cae10bb7234a0f4342"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lpuart__driver.html#ga42eaf9d7f780b53a6e974743122eebb0">lpuart_idle_type_select_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga45ac9d819675f5cae10bb7234a0f4342">_lpuart_config::rxIdleType</a></td></tr>
<tr class="separator:ga45ac9d819675f5cae10bb7234a0f4342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5389e158519dd57c804a10ef5dc3c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lpuart__driver.html#gaaf5c727d57d2e3dcf413d6dcdb3e74c1">lpuart_idle_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab5389e158519dd57c804a10ef5dc3c00">_lpuart_config::rxIdleConfig</a></td></tr>
<tr class="separator:gab5389e158519dd57c804a10ef5dc3c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9558be2149e5a5730eff2d7bb1fdb28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab9558be2149e5a5730eff2d7bb1fdb28">_lpuart_config::enableTx</a></td></tr>
<tr class="separator:gab9558be2149e5a5730eff2d7bb1fdb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5249f5987bbb04eb5ae5e9cfb6e5358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab5249f5987bbb04eb5ae5e9cfb6e5358">_lpuart_config::enableRx</a></td></tr>
<tr class="separator:gab5249f5987bbb04eb5ae5e9cfb6e5358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0e6f0be1311cf09de693c9a9ff9c70"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5f0e6f0be1311cf09de693c9a9ff9c70">_lpuart_transfer::data</a></td></tr>
<tr class="separator:ga5f0e6f0be1311cf09de693c9a9ff9c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa76dae4246c582cb20524f7c3b1be8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaaa76dae4246c582cb20524f7c3b1be8b">_lpuart_transfer::dataSize</a></td></tr>
<tr class="separator:gaaa76dae4246c582cb20524f7c3b1be8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee65bd1ba63882989180cb0b8904d6a"><td class="memItemLeft" align="right" valign="top">uint8_t *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5ee65bd1ba63882989180cb0b8904d6a">_lpuart_handle::txData</a></td></tr>
<tr class="separator:ga5ee65bd1ba63882989180cb0b8904d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7df82f52174be9a8d21f26eba8b63f"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga9c7df82f52174be9a8d21f26eba8b63f">_lpuart_handle::txDataSize</a></td></tr>
<tr class="separator:ga9c7df82f52174be9a8d21f26eba8b63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2535ea3d50a0e1ebc64ef678792ca143"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga2535ea3d50a0e1ebc64ef678792ca143">_lpuart_handle::txDataSizeAll</a></td></tr>
<tr class="separator:ga2535ea3d50a0e1ebc64ef678792ca143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f222c17b99b9528dabcc7bc2b2a54b"><td class="memItemLeft" align="right" valign="top">uint8_t *volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga22f222c17b99b9528dabcc7bc2b2a54b">_lpuart_handle::rxData</a></td></tr>
<tr class="separator:ga22f222c17b99b9528dabcc7bc2b2a54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc516aa43ddb7eeec9288820af1ecd89"><td class="memItemLeft" align="right" valign="top">volatile size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gacc516aa43ddb7eeec9288820af1ecd89">_lpuart_handle::rxDataSize</a></td></tr>
<tr class="separator:gacc516aa43ddb7eeec9288820af1ecd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae577a09ca8d3b9eb73f90d308d842e79"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae577a09ca8d3b9eb73f90d308d842e79">_lpuart_handle::rxDataSizeAll</a></td></tr>
<tr class="separator:gae577a09ca8d3b9eb73f90d308d842e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1100410b5924efeb1a55ec14e15d39f1"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga1100410b5924efeb1a55ec14e15d39f1">_lpuart_handle::rxRingBuffer</a></td></tr>
<tr class="separator:ga1100410b5924efeb1a55ec14e15d39f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08db8e558ba77d8c5ece4f60822f60c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga08db8e558ba77d8c5ece4f60822f60c3">_lpuart_handle::rxRingBufferSize</a></td></tr>
<tr class="separator:ga08db8e558ba77d8c5ece4f60822f60c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20aadb739214ab07e45cb9226132192e"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga20aadb739214ab07e45cb9226132192e">_lpuart_handle::rxRingBufferHead</a></td></tr>
<tr class="separator:ga20aadb739214ab07e45cb9226132192e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2777d723511750a6b39f5169135a909f"><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga2777d723511750a6b39f5169135a909f">_lpuart_handle::rxRingBufferTail</a></td></tr>
<tr class="separator:ga2777d723511750a6b39f5169135a909f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50459b72a63e6b30c8ed3671a8af981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__lpuart__driver.html#ga558e0c23c05831e446708a3935f36332">lpuart_transfer_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab50459b72a63e6b30c8ed3671a8af981">_lpuart_handle::callback</a></td></tr>
<tr class="separator:gab50459b72a63e6b30c8ed3671a8af981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ac81d3089f6b9b2772708b49502441"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae2ac81d3089f6b9b2772708b49502441">_lpuart_handle::userData</a></td></tr>
<tr class="separator:gae2ac81d3089f6b9b2772708b49502441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15865b470edd53b37c580981c718f559"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga15865b470edd53b37c580981c718f559">_lpuart_handle::txState</a></td></tr>
<tr class="separator:ga15865b470edd53b37c580981c718f559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac113a769dffef4a25e7ecac12c412893"><td class="memItemLeft" align="right" valign="top">volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gac113a769dffef4a25e7ecac12c412893">_lpuart_handle::rxState</a></td></tr>
<tr class="separator:gac113a769dffef4a25e7ecac12c412893"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Driver version</h2></td></tr>
<tr class="memitem:gab04a0655cd1e3bcac5e8f48c18df1a57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57abddb317db7dfffa95856604bfac2a17f">kStatus_LPUART_TxBusy</a> = MAKE_STATUS(kStatusGroup_LPUART, 0)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a98dfeab0a23c81f6b7f2c18acff8cc30">kStatus_LPUART_RxBusy</a> = MAKE_STATUS(kStatusGroup_LPUART, 1)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a079c6d0957d121ce7cd95cf97487dfbb">kStatus_LPUART_TxIdle</a> = MAKE_STATUS(kStatusGroup_LPUART, 2)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a02b8fe84bbfd8c52856b5d48865f7088">kStatus_LPUART_RxIdle</a> = MAKE_STATUS(kStatusGroup_LPUART, 3)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57abbee969cb0f7b4c49b44b10c4eb583cc">kStatus_LPUART_TxWatermarkTooLarge</a> = MAKE_STATUS(kStatusGroup_LPUART, 4)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57aca81b4d6e2e792c6d841b95ec25daad9">kStatus_LPUART_RxWatermarkTooLarge</a> = MAKE_STATUS(kStatusGroup_LPUART, 5)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a07d5a5092ded158fe53ea4df940f8bdb">kStatus_LPUART_FlagCannotClearManually</a> = MAKE_STATUS(kStatusGroup_LPUART, 6)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57af069a1997c3d25588d834ccb33dd35f4">kStatus_LPUART_Error</a> = MAKE_STATUS(kStatusGroup_LPUART, 7)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a45a7ed684f4c31aec8999b3da68d3b5e">kStatus_LPUART_RxRingBufferOverrun</a>
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57af8ada3eacff87751ec865b4fc584bac1">kStatus_LPUART_RxHardwareOverrun</a> = MAKE_STATUS(kStatusGroup_LPUART, 9)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a6ccebae2eb859fde044f15f1dd18cba1">kStatus_LPUART_NoiseError</a> = MAKE_STATUS(kStatusGroup_LPUART, 10)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a1528dc2aacb3a792a1ecbfbbc7941bc9">kStatus_LPUART_FramingError</a> = MAKE_STATUS(kStatusGroup_LPUART, 11)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57ad42bcd27cb6e04725768c6b98d4cbe0d">kStatus_LPUART_ParityError</a> = MAKE_STATUS(kStatusGroup_LPUART, 12)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57aaa020183f56b7d7f63e22fd5fd8d3df2">kStatus_LPUART_BaudrateNotSupport</a>
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a29540bf056281514eb42c8885f7e2e10">kStatus_LPUART_IdleLineDetected</a> = MAKE_STATUS(kStatusGroup_LPUART, 14)
, <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a0a6368e75ae51755bbd3f451c276c822">kStatus_LPUART_Timeout</a> = MAKE_STATUS(kStatusGroup_LPUART, 15)
<br />
 }</td></tr>
<tr class="memdesc:gab04a0655cd1e3bcac5e8f48c18df1a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for the LPUART driver.  <a href="group__lpuart__driver.html#gab04a0655cd1e3bcac5e8f48c18df1a57">More...</a><br /></td></tr>
<tr class="separator:gab04a0655cd1e3bcac5e8f48c18df1a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22a746cfd0fffff30eaf27f8795b2059"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga22a746cfd0fffff30eaf27f8795b2059">_lpuart_parity_mode</a> { <a class="el" href="group__lpuart__driver.html#gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a">kLPUART_ParityDisabled</a> = 0x0U
, <a class="el" href="group__lpuart__driver.html#gga22a746cfd0fffff30eaf27f8795b2059ac92adb3fdf11240ca5dee6c6543b6ff7">kLPUART_ParityEven</a> = 0x2U
, <a class="el" href="group__lpuart__driver.html#gga22a746cfd0fffff30eaf27f8795b2059adab63856e98e0715f4ab289ac0da3575">kLPUART_ParityOdd</a> = 0x3U
 }</td></tr>
<tr class="memdesc:ga22a746cfd0fffff30eaf27f8795b2059"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART parity mode.  <a href="group__lpuart__driver.html#ga22a746cfd0fffff30eaf27f8795b2059">More...</a><br /></td></tr>
<tr class="separator:ga22a746cfd0fffff30eaf27f8795b2059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565561e02414c90014f13391a1dd7dd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga565561e02414c90014f13391a1dd7dd5">_lpuart_data_bits</a> { <a class="el" href="group__lpuart__driver.html#gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899">kLPUART_EightDataBits</a> = 0x0U
 }</td></tr>
<tr class="memdesc:ga565561e02414c90014f13391a1dd7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART data bits count.  <a href="group__lpuart__driver.html#ga565561e02414c90014f13391a1dd7dd5">More...</a><br /></td></tr>
<tr class="separator:ga565561e02414c90014f13391a1dd7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad19fe7bcda436707337f6d529d5da155"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gad19fe7bcda436707337f6d529d5da155">_lpuart_stop_bit_count</a> { <a class="el" href="group__lpuart__driver.html#ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901">kLPUART_OneStopBit</a> = 0U
, <a class="el" href="group__lpuart__driver.html#ggad19fe7bcda436707337f6d529d5da155a6e049e0faaf89ed2dfe493ad8f6c93d4">kLPUART_TwoStopBit</a> = 1U
 }</td></tr>
<tr class="memdesc:gad19fe7bcda436707337f6d529d5da155"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART stop bit count.  <a href="group__lpuart__driver.html#gad19fe7bcda436707337f6d529d5da155">More...</a><br /></td></tr>
<tr class="separator:gad19fe7bcda436707337f6d529d5da155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f767cb7f8458682f742f2e7d4bda63d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5f767cb7f8458682f742f2e7d4bda63d">_lpuart_idle_type_select</a> { <a class="el" href="group__lpuart__driver.html#gga5f767cb7f8458682f742f2e7d4bda63da0644f6b95813c520dede56ee3a944267">kLPUART_IdleTypeStartBit</a> = 0U
, <a class="el" href="group__lpuart__driver.html#gga5f767cb7f8458682f742f2e7d4bda63da69545f21a3401c126bf295b5cf94225b">kLPUART_IdleTypeStopBit</a> = 1U
 }</td></tr>
<tr class="memdesc:ga5f767cb7f8458682f742f2e7d4bda63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART idle flag type defines when the receiver starts counting.  <a href="group__lpuart__driver.html#ga5f767cb7f8458682f742f2e7d4bda63d">More...</a><br /></td></tr>
<tr class="separator:ga5f767cb7f8458682f742f2e7d4bda63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c97cefe85629e606de5281d4eef25b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga13c97cefe85629e606de5281d4eef25b">_lpuart_idle_config</a> { <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25ba955e0bb4d3e75e577eef544b440c24be">kLPUART_IdleCharacter1</a> = 0U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25ba270caa8e77b08697404771af82abd131">kLPUART_IdleCharacter2</a> = 1U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25bacab443d3d053070635ea1f859b73f34c">kLPUART_IdleCharacter4</a> = 2U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25baf125ff40887939add6dd0f42d4485bf3">kLPUART_IdleCharacter8</a> = 3U
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25bace45d3af9a0c590f053df7bb00e6582a">kLPUART_IdleCharacter16</a> = 4U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25ba1daee04c54b7e37ca5e7331a3e1e7374">kLPUART_IdleCharacter32</a> = 5U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25bac497a53ed2755d26961f3b72fbd180ed">kLPUART_IdleCharacter64</a> = 6U
, <a class="el" href="group__lpuart__driver.html#gga13c97cefe85629e606de5281d4eef25ba4e080722efa87475f1710f5524e50c67">kLPUART_IdleCharacter128</a> = 7U
<br />
 }</td></tr>
<tr class="memdesc:ga13c97cefe85629e606de5281d4eef25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART idle detected configuration. This structure defines the number of idle characters that must be received before the IDLE flag is set.  <a href="group__lpuart__driver.html#ga13c97cefe85629e606de5281d4eef25b">More...</a><br /></td></tr>
<tr class="separator:ga13c97cefe85629e606de5281d4eef25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199a157d391291a9d003bf23954f9603"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a> { <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a43750aac20f72535350c1ab4a1862a3a">kLPUART_RxActiveEdgeInterruptEnable</a> = (LPUART_BAUD_RXEDGIE_MASK &gt;&gt; 8)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c">kLPUART_TxDataRegEmptyInterruptEnable</a> = (LPUART_CTRL_TIE_MASK)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0b7f783393a61cce88eab28307e9fe14">kLPUART_TransmissionCompleteInterruptEnable</a> = (LPUART_CTRL_TCIE_MASK)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22">kLPUART_RxDataRegFullInterruptEnable</a> = (LPUART_CTRL_RIE_MASK)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603af3f83c56032b14e50a682857dd7c152d">kLPUART_IdleLineInterruptEnable</a> = (LPUART_CTRL_ILIE_MASK)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a8a29c714eaa6acab06a87314f4f29636">kLPUART_RxOverrunInterruptEnable</a> = (LPUART_CTRL_ORIE_MASK)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603ad1a35bc7e89f170a5b82cb4801b73b5e">kLPUART_NoiseErrorInterruptEnable</a> = (LPUART_CTRL_NEIE_MASK)
, <a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a1b43ca06e0af6b0fcf4b55612363a64d">kLPUART_FramingErrorInterruptEnable</a> = (LPUART_CTRL_FEIE_MASK)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a13c12b816605deaabcbc3e6a6db82466">kLPUART_ParityErrorInterruptEnable</a> = (LPUART_CTRL_PEIE_MASK)
<br />
 }</td></tr>
<tr class="memdesc:ga199a157d391291a9d003bf23954f9603"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART interrupt configuration structure, default settings all disabled.  <a href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">More...</a><br /></td></tr>
<tr class="separator:ga199a157d391291a9d003bf23954f9603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24bb7ca3f894fe5ff55b9f38bec16c89"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga24bb7ca3f894fe5ff55b9f38bec16c89">_lpuart_flags</a> { <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a">kLPUART_TxDataRegEmptyFlag</a>
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89ae0539c4cf39d4d1e7839a4896fad2a85">kLPUART_TransmissionCompleteFlag</a>
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89a9bc679bcc20b81768f84b04e499c5a2f">kLPUART_RxDataRegFullFlag</a>
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89acf1a40aca38878bc395f9f0b10d8225e">kLPUART_IdleLineFlag</a> = (LPUART_STAT_IDLE_MASK)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89a994f5f484509133c632215a8b701f8d1">kLPUART_RxOverrunFlag</a> = (LPUART_STAT_OR_MASK)
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89a2198232cb9d239f937ab221bbf03259f">kLPUART_NoiseErrorFlag</a> = (LPUART_STAT_NF_MASK)
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89ad1d40f89cb6aab9c12113586fda7f510">kLPUART_FramingErrorFlag</a>
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89a2f8d4c03df61bc4678b2ccf1c69eedeb">kLPUART_ParityErrorFlag</a> = (LPUART_STAT_PF_MASK)
, <br />
&#160;&#160;<a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89ae89f181d8dbbf5254d6fe843e4cac6d6">kLPUART_RxActiveEdgeFlag</a>
, <a class="el" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89a1f14711a74db1cc141b5c2627ee4c799">kLPUART_RxActiveFlag</a>
<br />
 }</td></tr>
<tr class="memdesc:ga24bb7ca3f894fe5ff55b9f38bec16c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART status flags.  <a href="group__lpuart__driver.html#ga24bb7ca3f894fe5ff55b9f38bec16c89">More...</a><br /></td></tr>
<tr class="separator:ga24bb7ca3f894fe5ff55b9f38bec16c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaade003e399c40357cf787b87e39083a1"><td class="memItemLeft" align="right" valign="top"><a id="gaade003e399c40357cf787b87e39083a1"></a>
typedef enum <a class="el" href="group__lpuart__driver.html#ga22a746cfd0fffff30eaf27f8795b2059">_lpuart_parity_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaade003e399c40357cf787b87e39083a1">lpuart_parity_mode_t</a></td></tr>
<tr class="memdesc:gaade003e399c40357cf787b87e39083a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART parity mode. <br /></td></tr>
<tr class="separator:gaade003e399c40357cf787b87e39083a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6785b5dcafe473d18fd40d490251c5eb"><td class="memItemLeft" align="right" valign="top"><a id="ga6785b5dcafe473d18fd40d490251c5eb"></a>
typedef enum <a class="el" href="group__lpuart__driver.html#ga565561e02414c90014f13391a1dd7dd5">_lpuart_data_bits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga6785b5dcafe473d18fd40d490251c5eb">lpuart_data_bits_t</a></td></tr>
<tr class="memdesc:ga6785b5dcafe473d18fd40d490251c5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART data bits count. <br /></td></tr>
<tr class="separator:ga6785b5dcafe473d18fd40d490251c5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71791788f61f7823dbce863f45560ac"><td class="memItemLeft" align="right" valign="top"><a id="gaa71791788f61f7823dbce863f45560ac"></a>
typedef enum <a class="el" href="group__lpuart__driver.html#gad19fe7bcda436707337f6d529d5da155">_lpuart_stop_bit_count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaa71791788f61f7823dbce863f45560ac">lpuart_stop_bit_count_t</a></td></tr>
<tr class="memdesc:gaa71791788f61f7823dbce863f45560ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART stop bit count. <br /></td></tr>
<tr class="separator:gaa71791788f61f7823dbce863f45560ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42eaf9d7f780b53a6e974743122eebb0"><td class="memItemLeft" align="right" valign="top"><a id="ga42eaf9d7f780b53a6e974743122eebb0"></a>
typedef enum <a class="el" href="group__lpuart__driver.html#ga5f767cb7f8458682f742f2e7d4bda63d">_lpuart_idle_type_select</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga42eaf9d7f780b53a6e974743122eebb0">lpuart_idle_type_select_t</a></td></tr>
<tr class="memdesc:ga42eaf9d7f780b53a6e974743122eebb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART idle flag type defines when the receiver starts counting. <br /></td></tr>
<tr class="separator:ga42eaf9d7f780b53a6e974743122eebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf5c727d57d2e3dcf413d6dcdb3e74c1"><td class="memItemLeft" align="right" valign="top"><a id="gaaf5c727d57d2e3dcf413d6dcdb3e74c1"></a>
typedef enum <a class="el" href="group__lpuart__driver.html#ga13c97cefe85629e606de5281d4eef25b">_lpuart_idle_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaaf5c727d57d2e3dcf413d6dcdb3e74c1">lpuart_idle_config_t</a></td></tr>
<tr class="memdesc:gaaf5c727d57d2e3dcf413d6dcdb3e74c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART idle detected configuration. This structure defines the number of idle characters that must be received before the IDLE flag is set. <br /></td></tr>
<tr class="separator:gaaf5c727d57d2e3dcf413d6dcdb3e74c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8386269b3452ae51c17c941d79ec7a39"><td class="memItemLeft" align="right" valign="top"><a id="ga8386269b3452ae51c17c941d79ec7a39"></a>
typedef struct <a class="el" href="struct__lpuart__config.html">_lpuart_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga8386269b3452ae51c17c941d79ec7a39">lpuart_config_t</a></td></tr>
<tr class="memdesc:ga8386269b3452ae51c17c941d79ec7a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART configuration structure. <br /></td></tr>
<tr class="separator:ga8386269b3452ae51c17c941d79ec7a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa4668de3b88738217a6dad33354b37"><td class="memItemLeft" align="right" valign="top"><a id="ga3aa4668de3b88738217a6dad33354b37"></a>
typedef struct <a class="el" href="struct__lpuart__transfer.html">_lpuart_transfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37">lpuart_transfer_t</a></td></tr>
<tr class="memdesc:ga3aa4668de3b88738217a6dad33354b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART transfer structure. <br /></td></tr>
<tr class="separator:ga3aa4668de3b88738217a6dad33354b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae5fcbb252991c5f0cdc72dc8deae25"><td class="memItemLeft" align="right" valign="top"><a id="gaeae5fcbb252991c5f0cdc72dc8deae25"></a>
typedef struct <a class="el" href="struct__lpuart__handle.html">_lpuart_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lpuart_handle_t</b></td></tr>
<tr class="separator:gaeae5fcbb252991c5f0cdc72dc8deae25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558e0c23c05831e446708a3935f36332"><td class="memItemLeft" align="right" valign="top"><a id="ga558e0c23c05831e446708a3935f36332"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga558e0c23c05831e446708a3935f36332">lpuart_transfer_callback_t</a>) (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, <a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> status, void *userData)</td></tr>
<tr class="memdesc:ga558e0c23c05831e446708a3935f36332"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART transfer callback function. <br /></td></tr>
<tr class="separator:ga558e0c23c05831e446708a3935f36332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0870fb824ece32739bd35f819f8c408e"><td class="memItemLeft" align="right" valign="top"><a id="ga0870fb824ece32739bd35f819f8c408e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga0870fb824ece32739bd35f819f8c408e">FSL_LPUART_DRIVER_VERSION</a>&#160;&#160;&#160;(<a class="el" href="group__ksdk__common.html#ga812138aa3315b0c6953c1a26130bcc37">MAKE_VERSION</a>(2, 4, 1))</td></tr>
<tr class="memdesc:ga0870fb824ece32739bd35f819f8c408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART driver version. <br /></td></tr>
<tr class="separator:ga0870fb824ece32739bd35f819f8c408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f88b67f77fd05f186a5ec940c340bd"><td class="memItemLeft" align="right" valign="top"><a id="gac0f88b67f77fd05f186a5ec940c340bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gac0f88b67f77fd05f186a5ec940c340bd">UART_RETRY_TIMES</a>&#160;&#160;&#160;0U /* Defining to zero means to keep waiting for the flag until it is assert/deassert. */</td></tr>
<tr class="memdesc:gac0f88b67f77fd05f186a5ec940c340bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retry times for waiting flag. <br /></td></tr>
<tr class="separator:gac0f88b67f77fd05f186a5ec940c340bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Initialization and deinitialization</h2></td></tr>
<tr class="memitem:ga26ce3e5d63d8dd5d317a83f22af9682c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga26ce3e5d63d8dd5d317a83f22af9682c">LPUART_Init</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, const <a class="el" href="group__lpuart__driver.html#ga8386269b3452ae51c17c941d79ec7a39">lpuart_config_t</a> *config, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:ga26ce3e5d63d8dd5d317a83f22af9682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an LPUART instance with the user configuration structure and the peripheral clock.  <a href="group__lpuart__driver.html#ga26ce3e5d63d8dd5d317a83f22af9682c">More...</a><br /></td></tr>
<tr class="separator:ga26ce3e5d63d8dd5d317a83f22af9682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303ff3b77767bafa449d96f1e8c921e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga303ff3b77767bafa449d96f1e8c921e0">LPUART_Deinit</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base)</td></tr>
<tr class="memdesc:ga303ff3b77767bafa449d96f1e8c921e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes a LPUART instance.  <a href="group__lpuart__driver.html#ga303ff3b77767bafa449d96f1e8c921e0">More...</a><br /></td></tr>
<tr class="separator:ga303ff3b77767bafa449d96f1e8c921e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95dfe3c3886692f1fe32023d59708440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga95dfe3c3886692f1fe32023d59708440">LPUART_GetDefaultConfig</a> (<a class="el" href="group__lpuart__driver.html#ga8386269b3452ae51c17c941d79ec7a39">lpuart_config_t</a> *config)</td></tr>
<tr class="memdesc:ga95dfe3c3886692f1fe32023d59708440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default configuration structure.  <a href="group__lpuart__driver.html#ga95dfe3c3886692f1fe32023d59708440">More...</a><br /></td></tr>
<tr class="separator:ga95dfe3c3886692f1fe32023d59708440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03d9292f8b4cb6e9748cb0bc1db7577"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaf03d9292f8b4cb6e9748cb0bc1db7577">LPUART_SetBaudRate</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:gaf03d9292f8b4cb6e9748cb0bc1db7577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LPUART instance baudrate.  <a href="group__lpuart__driver.html#gaf03d9292f8b4cb6e9748cb0bc1db7577">More...</a><br /></td></tr>
<tr class="separator:gaf03d9292f8b4cb6e9748cb0bc1db7577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e13bb206bd78070737968610437fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae7e13bb206bd78070737968610437fb1">LPUART_Enable9bitMode</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, bool enable)</td></tr>
<tr class="memdesc:gae7e13bb206bd78070737968610437fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable 9-bit data mode for LPUART.  <a href="group__lpuart__driver.html#gae7e13bb206bd78070737968610437fb1">More...</a><br /></td></tr>
<tr class="separator:gae7e13bb206bd78070737968610437fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Status</h2></td></tr>
<tr class="memitem:gab83db963591b116f90daf3e24118cb09"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab83db963591b116f90daf3e24118cb09">LPUART_GetStatusFlags</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base)</td></tr>
<tr class="memdesc:gab83db963591b116f90daf3e24118cb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets LPUART status flags.  <a href="group__lpuart__driver.html#gab83db963591b116f90daf3e24118cb09">More...</a><br /></td></tr>
<tr class="separator:gab83db963591b116f90daf3e24118cb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6bcdb29d31a2addb8d80d98855ba147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gac6bcdb29d31a2addb8d80d98855ba147">LPUART_ClearStatusFlags</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:gac6bcdb29d31a2addb8d80d98855ba147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears status flags with a provided mask.  <a href="group__lpuart__driver.html#gac6bcdb29d31a2addb8d80d98855ba147">More...</a><br /></td></tr>
<tr class="separator:gac6bcdb29d31a2addb8d80d98855ba147"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Interrupts</h2></td></tr>
<tr class="memitem:gab5998ebb0dc457f0864c84c16f83d745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gab5998ebb0dc457f0864c84c16f83d745">LPUART_EnableInterrupts</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:gab5998ebb0dc457f0864c84c16f83d745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables LPUART interrupts according to a provided mask.  <a href="group__lpuart__driver.html#gab5998ebb0dc457f0864c84c16f83d745">More...</a><br /></td></tr>
<tr class="separator:gab5998ebb0dc457f0864c84c16f83d745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2540406e4a338199acddaa828829cad8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga2540406e4a338199acddaa828829cad8">LPUART_DisableInterrupts</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:ga2540406e4a338199acddaa828829cad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables LPUART interrupts according to a provided mask.  <a href="group__lpuart__driver.html#ga2540406e4a338199acddaa828829cad8">More...</a><br /></td></tr>
<tr class="separator:ga2540406e4a338199acddaa828829cad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172b524bae8bacc6dc95d9daf82c97b5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga172b524bae8bacc6dc95d9daf82c97b5">LPUART_GetEnabledInterrupts</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base)</td></tr>
<tr class="memdesc:ga172b524bae8bacc6dc95d9daf82c97b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets enabled LPUART interrupts.  <a href="group__lpuart__driver.html#ga172b524bae8bacc6dc95d9daf82c97b5">More...</a><br /></td></tr>
<tr class="separator:ga172b524bae8bacc6dc95d9daf82c97b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Bus Operations</h2></td></tr>
<tr class="memitem:gaaf4c8ce1f1730cdbf094931033d9b52c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gaaf4c8ce1f1730cdbf094931033d9b52c">LPUART_GetInstance</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base)</td></tr>
<tr class="memdesc:gaaf4c8ce1f1730cdbf094931033d9b52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the LPUART instance from peripheral base address.  <a href="group__lpuart__driver.html#gaaf4c8ce1f1730cdbf094931033d9b52c">More...</a><br /></td></tr>
<tr class="separator:gaaf4c8ce1f1730cdbf094931033d9b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a7dbe15a9f822847791cebe75d5394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga85a7dbe15a9f822847791cebe75d5394">LPUART_SendAddress</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint8_t address)</td></tr>
<tr class="memdesc:ga85a7dbe15a9f822847791cebe75d5394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit an address frame in 9-bit data mode.  <a href="group__lpuart__driver.html#ga85a7dbe15a9f822847791cebe75d5394">More...</a><br /></td></tr>
<tr class="separator:ga85a7dbe15a9f822847791cebe75d5394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2699958de62ff4832f95bc2dd8c454a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga2699958de62ff4832f95bc2dd8c454a5">LPUART_WriteBlocking</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga2699958de62ff4832f95bc2dd8c454a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the transmitter register using a blocking method.  <a href="group__lpuart__driver.html#ga2699958de62ff4832f95bc2dd8c454a5">More...</a><br /></td></tr>
<tr class="separator:ga2699958de62ff4832f95bc2dd8c454a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76aba14dbfe94124082785e2c0ecd9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gae76aba14dbfe94124082785e2c0ecd9d">LPUART_ReadBlocking</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gae76aba14dbfe94124082785e2c0ecd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the receiver data register using a blocking method.  <a href="group__lpuart__driver.html#gae76aba14dbfe94124082785e2c0ecd9d">More...</a><br /></td></tr>
<tr class="separator:gae76aba14dbfe94124082785e2c0ecd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Transactional</h2></td></tr>
<tr class="memitem:ga10eae12610523a624c1016882f8dba5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga10eae12610523a624c1016882f8dba5f">LPUART_TransferCreateHandle</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, <a class="el" href="group__lpuart__driver.html#ga558e0c23c05831e446708a3935f36332">lpuart_transfer_callback_t</a> callback, void *userData)</td></tr>
<tr class="memdesc:ga10eae12610523a624c1016882f8dba5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the LPUART handle.  <a href="group__lpuart__driver.html#ga10eae12610523a624c1016882f8dba5f">More...</a><br /></td></tr>
<tr class="separator:ga10eae12610523a624c1016882f8dba5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba986c473e5935131e63cb882cf26ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gafba986c473e5935131e63cb882cf26ff">LPUART_TransferSendNonBlocking</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, <a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37">lpuart_transfer_t</a> *xfer)</td></tr>
<tr class="memdesc:gafba986c473e5935131e63cb882cf26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a buffer of data using the interrupt method.  <a href="group__lpuart__driver.html#gafba986c473e5935131e63cb882cf26ff">More...</a><br /></td></tr>
<tr class="separator:gafba986c473e5935131e63cb882cf26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5257b77491042af5913a8d91c66318e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga5257b77491042af5913a8d91c66318e1">LPUART_TransferStartRingBuffer</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, uint8_t *ringBuffer, size_t ringBufferSize)</td></tr>
<tr class="memdesc:ga5257b77491042af5913a8d91c66318e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the RX ring buffer.  <a href="group__lpuart__driver.html#ga5257b77491042af5913a8d91c66318e1">More...</a><br /></td></tr>
<tr class="separator:ga5257b77491042af5913a8d91c66318e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a230a664808592aab153ea20e3d60b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gad6a230a664808592aab153ea20e3d60b">LPUART_TransferStopRingBuffer</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gad6a230a664808592aab153ea20e3d60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the background transfer and uninstalls the ring buffer.  <a href="group__lpuart__driver.html#gad6a230a664808592aab153ea20e3d60b">More...</a><br /></td></tr>
<tr class="separator:gad6a230a664808592aab153ea20e3d60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550523d301acfa413919c2f979228bcc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga550523d301acfa413919c2f979228bcc">LPUART_TransferGetRxRingBufferLength</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga550523d301acfa413919c2f979228bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of received data in RX ring buffer.  <a href="group__lpuart__driver.html#ga550523d301acfa413919c2f979228bcc">More...</a><br /></td></tr>
<tr class="separator:ga550523d301acfa413919c2f979228bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dfe9efe9656e126c70ee79fa03f2be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga6dfe9efe9656e126c70ee79fa03f2be3">LPUART_TransferAbortSend</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga6dfe9efe9656e126c70ee79fa03f2be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the interrupt-driven data transmit.  <a href="group__lpuart__driver.html#ga6dfe9efe9656e126c70ee79fa03f2be3">More...</a><br /></td></tr>
<tr class="separator:ga6dfe9efe9656e126c70ee79fa03f2be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad80d2469dce0de9361e731e4cefde9fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gad80d2469dce0de9361e731e4cefde9fd">LPUART_TransferGetSendCount</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, uint32_t *count)</td></tr>
<tr class="memdesc:gad80d2469dce0de9361e731e4cefde9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes that have been sent out to bus.  <a href="group__lpuart__driver.html#gad80d2469dce0de9361e731e4cefde9fd">More...</a><br /></td></tr>
<tr class="separator:gad80d2469dce0de9361e731e4cefde9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bdb584704ce7955004751e32627f918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga8bdb584704ce7955004751e32627f918">LPUART_TransferReceiveNonBlocking</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, <a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37">lpuart_transfer_t</a> *xfer, size_t *receivedBytes)</td></tr>
<tr class="memdesc:ga8bdb584704ce7955004751e32627f918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a buffer of data using the interrupt method.  <a href="group__lpuart__driver.html#ga8bdb584704ce7955004751e32627f918">More...</a><br /></td></tr>
<tr class="separator:ga8bdb584704ce7955004751e32627f918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4950fa0f3835992251c109f655a3ca7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga4950fa0f3835992251c109f655a3ca7d">LPUART_TransferAbortReceive</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga4950fa0f3835992251c109f655a3ca7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the interrupt-driven data receiving.  <a href="group__lpuart__driver.html#ga4950fa0f3835992251c109f655a3ca7d">More...</a><br /></td></tr>
<tr class="separator:ga4950fa0f3835992251c109f655a3ca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcdc658c463e9e7523cc60c5e8f9672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gabfcdc658c463e9e7523cc60c5e8f9672">LPUART_TransferGetReceiveCount</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle, uint32_t *count)</td></tr>
<tr class="memdesc:gabfcdc658c463e9e7523cc60c5e8f9672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes that have been received.  <a href="group__lpuart__driver.html#gabfcdc658c463e9e7523cc60c5e8f9672">More...</a><br /></td></tr>
<tr class="separator:gabfcdc658c463e9e7523cc60c5e8f9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81ce3c490d7185ab7e2d97963ae077e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#gac81ce3c490d7185ab7e2d97963ae077e">LPUART_TransferHandleIRQ</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gac81ce3c490d7185ab7e2d97963ae077e"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART IRQ handle function.  <a href="group__lpuart__driver.html#gac81ce3c490d7185ab7e2d97963ae077e">More...</a><br /></td></tr>
<tr class="separator:gac81ce3c490d7185ab7e2d97963ae077e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21345340b5d8f90df6bb64acab0f870f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lpuart__driver.html#ga21345340b5d8f90df6bb64acab0f870f">LPUART_TransferHandleErrorIRQ</a> (<a class="el" href="structLPUART__Type.html">LPUART_Type</a> *base, <a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga21345340b5d8f90df6bb64acab0f870f"><td class="mdescLeft">&#160;</td><td class="mdescRight">LPUART Error IRQ handle function.  <a href="group__lpuart__driver.html#ga21345340b5d8f90df6bb64acab0f870f">More...</a><br /></td></tr>
<tr class="separator:ga21345340b5d8f90df6bb64acab0f870f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab04a0655cd1e3bcac5e8f48c18df1a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab04a0655cd1e3bcac5e8f48c18df1a57">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes for the LPUART driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57abddb317db7dfffa95856604bfac2a17f"></a>kStatus_LPUART_TxBusy&#160;</td><td class="fielddoc"><p>TX busy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a98dfeab0a23c81f6b7f2c18acff8cc30"></a>kStatus_LPUART_RxBusy&#160;</td><td class="fielddoc"><p>RX busy </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a079c6d0957d121ce7cd95cf97487dfbb"></a>kStatus_LPUART_TxIdle&#160;</td><td class="fielddoc"><p>LPUART transmitter is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a02b8fe84bbfd8c52856b5d48865f7088"></a>kStatus_LPUART_RxIdle&#160;</td><td class="fielddoc"><p>LPUART receiver is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57abbee969cb0f7b4c49b44b10c4eb583cc"></a>kStatus_LPUART_TxWatermarkTooLarge&#160;</td><td class="fielddoc"><p>TX FIFO watermark too large <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57aca81b4d6e2e792c6d841b95ec25daad9"></a>kStatus_LPUART_RxWatermarkTooLarge&#160;</td><td class="fielddoc"><p>RX FIFO watermark too large <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a07d5a5092ded158fe53ea4df940f8bdb"></a>kStatus_LPUART_FlagCannotClearManually&#160;</td><td class="fielddoc"><p>Some flag can't manually clear </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57af069a1997c3d25588d834ccb33dd35f4"></a>kStatus_LPUART_Error&#160;</td><td class="fielddoc"><p>Error happens on LPUART. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a45a7ed684f4c31aec8999b3da68d3b5e"></a>kStatus_LPUART_RxRingBufferOverrun&#160;</td><td class="fielddoc"><p>LPUART RX software ring buffer overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57af8ada3eacff87751ec865b4fc584bac1"></a>kStatus_LPUART_RxHardwareOverrun&#160;</td><td class="fielddoc"><p>LPUART RX receiver overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a6ccebae2eb859fde044f15f1dd18cba1"></a>kStatus_LPUART_NoiseError&#160;</td><td class="fielddoc"><p>LPUART noise error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a1528dc2aacb3a792a1ecbfbbc7941bc9"></a>kStatus_LPUART_FramingError&#160;</td><td class="fielddoc"><p>LPUART framing error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57ad42bcd27cb6e04725768c6b98d4cbe0d"></a>kStatus_LPUART_ParityError&#160;</td><td class="fielddoc"><p>LPUART parity error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57aaa020183f56b7d7f63e22fd5fd8d3df2"></a>kStatus_LPUART_BaudrateNotSupport&#160;</td><td class="fielddoc"><p>Baudrate is not support in current clock source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a29540bf056281514eb42c8885f7e2e10"></a>kStatus_LPUART_IdleLineDetected&#160;</td><td class="fielddoc"><p>IDLE flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggab04a0655cd1e3bcac5e8f48c18df1a57a0a6368e75ae51755bbd3f451c276c822"></a>kStatus_LPUART_Timeout&#160;</td><td class="fielddoc"><p>LPUART times out. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga565561e02414c90014f13391a1dd7dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565561e02414c90014f13391a1dd7dd5">&#9670;&nbsp;</a></span>_lpuart_data_bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga565561e02414c90014f13391a1dd7dd5">_lpuart_data_bits</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART data bits count. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899"></a>kLPUART_EightDataBits&#160;</td><td class="fielddoc"><p>Eight data bit </p>
</td></tr>
</table>

</div>
</div>
<a id="ga24bb7ca3f894fe5ff55b9f38bec16c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24bb7ca3f894fe5ff55b9f38bec16c89">&#9670;&nbsp;</a></span>_lpuart_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga24bb7ca3f894fe5ff55b9f38bec16c89">_lpuart_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART status flags. </p>
<p>This provides constants for the LPUART status flags for use in the LPUART functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a"></a>kLPUART_TxDataRegEmptyFlag&#160;</td><td class="fielddoc"><p>Transmit data register empty flag, sets when transmit buffer is empty </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89ae0539c4cf39d4d1e7839a4896fad2a85"></a>kLPUART_TransmissionCompleteFlag&#160;</td><td class="fielddoc"><p>Transmission complete flag, sets when transmission activity complete </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89a9bc679bcc20b81768f84b04e499c5a2f"></a>kLPUART_RxDataRegFullFlag&#160;</td><td class="fielddoc"><p>Receive data register full flag, sets when the receive data buffer is full </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89acf1a40aca38878bc395f9f0b10d8225e"></a>kLPUART_IdleLineFlag&#160;</td><td class="fielddoc"><p>Idle line detect flag, sets when idle line detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89a994f5f484509133c632215a8b701f8d1"></a>kLPUART_RxOverrunFlag&#160;</td><td class="fielddoc"><p>Receive Overrun, sets when new data is received before data is read from receive register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89a2198232cb9d239f937ab221bbf03259f"></a>kLPUART_NoiseErrorFlag&#160;</td><td class="fielddoc"><p>Receive takes 3 samples of each received bit. If any of these samples differ, noise flag sets </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89ad1d40f89cb6aab9c12113586fda7f510"></a>kLPUART_FramingErrorFlag&#160;</td><td class="fielddoc"><p>Frame error flag, sets if logic 0 was detected where stop bit expected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89a2f8d4c03df61bc4678b2ccf1c69eedeb"></a>kLPUART_ParityErrorFlag&#160;</td><td class="fielddoc"><p>If parity enabled, sets upon parity error detection </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89ae89f181d8dbbf5254d6fe843e4cac6d6"></a>kLPUART_RxActiveEdgeFlag&#160;</td><td class="fielddoc"><p>Receive pin active edge interrupt flag, sets when active edge detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga24bb7ca3f894fe5ff55b9f38bec16c89a1f14711a74db1cc141b5c2627ee4c799"></a>kLPUART_RxActiveFlag&#160;</td><td class="fielddoc"><p>Receiver Active Flag (RAF), sets at beginning of valid start bit </p>
</td></tr>
</table>

</div>
</div>
<a id="ga13c97cefe85629e606de5281d4eef25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c97cefe85629e606de5281d4eef25b">&#9670;&nbsp;</a></span>_lpuart_idle_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga13c97cefe85629e606de5281d4eef25b">_lpuart_idle_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART idle detected configuration. This structure defines the number of idle characters that must be received before the IDLE flag is set. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25ba955e0bb4d3e75e577eef544b440c24be"></a>kLPUART_IdleCharacter1&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25ba270caa8e77b08697404771af82abd131"></a>kLPUART_IdleCharacter2&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25bacab443d3d053070635ea1f859b73f34c"></a>kLPUART_IdleCharacter4&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25baf125ff40887939add6dd0f42d4485bf3"></a>kLPUART_IdleCharacter8&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25bace45d3af9a0c590f053df7bb00e6582a"></a>kLPUART_IdleCharacter16&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25ba1daee04c54b7e37ca5e7331a3e1e7374"></a>kLPUART_IdleCharacter32&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25bac497a53ed2755d26961f3b72fbd180ed"></a>kLPUART_IdleCharacter64&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga13c97cefe85629e606de5281d4eef25ba4e080722efa87475f1710f5524e50c67"></a>kLPUART_IdleCharacter128&#160;</td><td class="fielddoc"><p>the number of idle characters. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga5f767cb7f8458682f742f2e7d4bda63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f767cb7f8458682f742f2e7d4bda63d">&#9670;&nbsp;</a></span>_lpuart_idle_type_select</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga5f767cb7f8458682f742f2e7d4bda63d">_lpuart_idle_type_select</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART idle flag type defines when the receiver starts counting. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5f767cb7f8458682f742f2e7d4bda63da0644f6b95813c520dede56ee3a944267"></a>kLPUART_IdleTypeStartBit&#160;</td><td class="fielddoc"><p>Start counting after a valid start bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5f767cb7f8458682f742f2e7d4bda63da69545f21a3401c126bf295b5cf94225b"></a>kLPUART_IdleTypeStopBit&#160;</td><td class="fielddoc"><p>Start counting after a stop bit. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga199a157d391291a9d003bf23954f9603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199a157d391291a9d003bf23954f9603">&#9670;&nbsp;</a></span>_lpuart_interrupt_enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART interrupt configuration structure, default settings all disabled. </p>
<p>This structure contains the settings for all LPUART interrupt configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a43750aac20f72535350c1ab4a1862a3a"></a>kLPUART_RxActiveEdgeInterruptEnable&#160;</td><td class="fielddoc"><p>Receive Active Edge. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c"></a>kLPUART_TxDataRegEmptyInterruptEnable&#160;</td><td class="fielddoc"><p>Transmit data register empty. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a0b7f783393a61cce88eab28307e9fe14"></a>kLPUART_TransmissionCompleteInterruptEnable&#160;</td><td class="fielddoc"><p>Transmission complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22"></a>kLPUART_RxDataRegFullInterruptEnable&#160;</td><td class="fielddoc"><p>Receiver data register full. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603af3f83c56032b14e50a682857dd7c152d"></a>kLPUART_IdleLineInterruptEnable&#160;</td><td class="fielddoc"><p>Idle line. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a8a29c714eaa6acab06a87314f4f29636"></a>kLPUART_RxOverrunInterruptEnable&#160;</td><td class="fielddoc"><p>Receiver Overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603ad1a35bc7e89f170a5b82cb4801b73b5e"></a>kLPUART_NoiseErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Noise error flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a1b43ca06e0af6b0fcf4b55612363a64d"></a>kLPUART_FramingErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Framing error flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga199a157d391291a9d003bf23954f9603a13c12b816605deaabcbc3e6a6db82466"></a>kLPUART_ParityErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Parity error flag. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga22a746cfd0fffff30eaf27f8795b2059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22a746cfd0fffff30eaf27f8795b2059">&#9670;&nbsp;</a></span>_lpuart_parity_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#ga22a746cfd0fffff30eaf27f8795b2059">_lpuart_parity_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART parity mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a"></a>kLPUART_ParityDisabled&#160;</td><td class="fielddoc"><p>Parity disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga22a746cfd0fffff30eaf27f8795b2059ac92adb3fdf11240ca5dee6c6543b6ff7"></a>kLPUART_ParityEven&#160;</td><td class="fielddoc"><p>Parity enabled, type even, bit setting: PE|PT = 10 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga22a746cfd0fffff30eaf27f8795b2059adab63856e98e0715f4ab289ac0da3575"></a>kLPUART_ParityOdd&#160;</td><td class="fielddoc"><p>Parity enabled, type odd, bit setting: PE|PT = 11 </p>
</td></tr>
</table>

</div>
</div>
<a id="gad19fe7bcda436707337f6d529d5da155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad19fe7bcda436707337f6d529d5da155">&#9670;&nbsp;</a></span>_lpuart_stop_bit_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__lpuart__driver.html#gad19fe7bcda436707337f6d529d5da155">_lpuart_stop_bit_count</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART stop bit count. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901"></a>kLPUART_OneStopBit&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad19fe7bcda436707337f6d529d5da155a6e049e0faaf89ed2dfe493ad8f6c93d4"></a>kLPUART_TwoStopBit&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac6bcdb29d31a2addb8d80d98855ba147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6bcdb29d31a2addb8d80d98855ba147">&#9670;&nbsp;</a></span>LPUART_ClearStatusFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_ClearStatusFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears status flags with a provided mask. </p>
<p>This function clears LPUART status flags with a provided mask. Automatically cleared flags can't be cleared by this function. Flags that can only cleared or set by hardware are: kLPUART_TxDataRegEmptyFlag, kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag, kLPUART_RxActiveFlag, kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag, kLPUART_TxFifoEmptyFlag,kLPUART_RxFifoEmptyFlag Note: This API should be called when the Tx/Rx is idle, otherwise it takes no effects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>the status flags to be cleared. The user can use the enumerators in the _lpuart_status_flag_t to do the OR operation and get the mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 succeed, others failed. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_LPUART_FlagCannotClearManually</td><td>The flag can't be cleared by this function but it is cleared automatically by hardware. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Status in the mask are cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Clears status flags with a provided mask.</p>
<p>This function clears LPUART status flags with a provided mask. Automatically cleared flags can't be cleared by this function. Flags that can only cleared or set by hardware are: kLPUART_TxDataRegEmptyFlag, kLPUART_TransmissionCompleteFlag, kLPUART_RxDataRegFullFlag, kLPUART_RxActiveFlag, kLPUART_NoiseErrorInRxDataRegFlag, kLPUART_ParityErrorInRxDataRegFlag, kLPUART_TxFifoEmptyFlag,kLPUART_RxFifoEmptyFlag Note: This API should be called when the Tx/Rx is idle, otherwise it takes no effects.</p>
<p>param base LPUART peripheral base address. param mask the status flags to be cleared. The user can use the enumerators in the _lpuart_status_flag_t to do the OR operation and get the mask. return 0 succeed, others failed. retval kStatus_LPUART_FlagCannotClearManually The flag can't be cleared by this function but it is cleared automatically by hardware. retval kStatus_Success Status in the mask are cleared. </p>

</div>
</div>
<a id="ga303ff3b77767bafa449d96f1e8c921e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga303ff3b77767bafa449d96f1e8c921e0">&#9670;&nbsp;</a></span>LPUART_Deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_Deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitializes a LPUART instance. </p>
<p>This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Deinitializes a LPUART instance.</p>
<p>This function waits for transmit to complete, disables TX and RX, and disables the LPUART clock.</p>
<p>param base LPUART peripheral base address. </p>

</div>
</div>
<a id="ga2540406e4a338199acddaa828829cad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2540406e4a338199acddaa828829cad8">&#9670;&nbsp;</a></span>LPUART_DisableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_DisableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables LPUART interrupts according to a provided mask. </p>
<p>This function disables the LPUART interrupts according to a provided mask. The mask is a logical OR of enumeration members. See <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>. This example shows how to disable the TX empty interrupt and RX full interrupt: </p><div class="fragment"><div class="line"><a class="code" href="group__lpuart__driver.html#ga2540406e4a338199acddaa828829cad8">LPUART_DisableInterrupts</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>,<a class="code" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c">kLPUART_TxDataRegEmptyInterruptEnable</a> | <a class="code" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22">kLPUART_RxDataRegFullInterruptEnable</a>);</div>
<div class="ttc" id="agroup__LPUART__Peripheral__Access__Layer_html_ga73eb37d103f4e4f2d18ec3d3f5208ab9"><div class="ttname"><a href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a></div><div class="ttdeci">#define LPUART1</div><div class="ttdef"><b>Definition:</b> MIMXRT1021.h:24757</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_ga2540406e4a338199acddaa828829cad8"><div class="ttname"><a href="group__lpuart__driver.html#ga2540406e4a338199acddaa828829cad8">LPUART_DisableInterrupts</a></div><div class="ttdeci">void LPUART_DisableInterrupts(LPUART_Type *base, uint32_t mask)</div><div class="ttdoc">Disables LPUART interrupts according to a provided mask.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:732</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c"><div class="ttname"><a href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c">kLPUART_TxDataRegEmptyInterruptEnable</a></div><div class="ttdeci">@ kLPUART_TxDataRegEmptyInterruptEnable</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:130</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22"><div class="ttname"><a href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22">kLPUART_RxDataRegFullInterruptEnable</a></div><div class="ttdeci">@ kLPUART_RxDataRegFullInterruptEnable</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:132</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The interrupts to disable. Logical OR of <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Disables LPUART interrupts according to a provided mask.</p>
<p>This function disables the LPUART interrupts according to a provided mask. The mask is a logical OR of enumeration members. See ref _lpuart_interrupt_enable. This example shows how to disable the TX empty interrupt and RX full interrupt: code LPUART_DisableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFullInterruptEnable); endcode</p>
<p>param base LPUART peripheral base address. param mask The interrupts to disable. Logical OR of ref _lpuart_interrupt_enable. </p>

</div>
</div>
<a id="gae7e13bb206bd78070737968610437fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7e13bb206bd78070737968610437fb1">&#9670;&nbsp;</a></span>LPUART_Enable9bitMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_Enable9bitMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable 9-bit data mode for LPUART. </p>
<p>This function set the 9-bit mode for LPUART module. The 9th bit is not used for parity thus can be modified by user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">enable</td><td>true to enable, flase to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Enable 9-bit data mode for LPUART.</p>
<p>This function set the 9-bit mode for LPUART module. The 9th bit is not used for parity thus can be modified by user.</p>
<p>param base LPUART peripheral base address. param enable true to enable, flase to disable. </p>

</div>
</div>
<a id="gab5998ebb0dc457f0864c84c16f83d745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5998ebb0dc457f0864c84c16f83d745">&#9670;&nbsp;</a></span>LPUART_EnableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_EnableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables LPUART interrupts according to a provided mask. </p>
<p>This function enables the LPUART interrupts according to a provided mask. The mask is a logical OR of enumeration members. See the <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>. This examples shows how to enable TX empty interrupt and RX full interrupt: </p><div class="fragment"><div class="line"><a class="code" href="group__lpuart__driver.html#gab5998ebb0dc457f0864c84c16f83d745">LPUART_EnableInterrupts</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>,<a class="code" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c">kLPUART_TxDataRegEmptyInterruptEnable</a> | <a class="code" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22">kLPUART_RxDataRegFullInterruptEnable</a>);</div>
<div class="ttc" id="agroup__lpuart__driver_html_gab5998ebb0dc457f0864c84c16f83d745"><div class="ttname"><a href="group__lpuart__driver.html#gab5998ebb0dc457f0864c84c16f83d745">LPUART_EnableInterrupts</a></div><div class="ttdeci">void LPUART_EnableInterrupts(LPUART_Type *base, uint32_t mask)</div><div class="ttdoc">Enables LPUART interrupts according to a provided mask.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:708</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The interrupts to enable. Logical OR of the enumeration _uart_interrupt_enable.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Enables LPUART interrupts according to a provided mask.</p>
<p>This function enables the LPUART interrupts according to a provided mask. The mask is a logical OR of enumeration members. See the ref _lpuart_interrupt_enable. This examples shows how to enable TX empty interrupt and RX full interrupt: code LPUART_EnableInterrupts(LPUART1,kLPUART_TxDataRegEmptyInterruptEnable | kLPUART_RxDataRegFullInterruptEnable); endcode</p>
<p>param base LPUART peripheral base address. param mask The interrupts to enable. Logical OR of ref _uart_interrupt_enable. </p>

</div>
</div>
<a id="ga95dfe3c3886692f1fe32023d59708440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95dfe3c3886692f1fe32023d59708440">&#9670;&nbsp;</a></span>LPUART_GetDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_GetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lpuart__driver.html#ga8386269b3452ae51c17c941d79ec7a39">lpuart_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default configuration structure. </p>
<p>This function initializes the LPUART configuration structure to a default value. The default values are: lpuartConfig-&gt;baudRate_Bps = 115200U; lpuartConfig-&gt;parityMode = kLPUART_ParityDisabled; lpuartConfig-&gt;dataBitsCount = kLPUART_EightDataBits; lpuartConfig-&gt;isMsb = false; lpuartConfig-&gt;stopBitCount = kLPUART_OneStopBit; lpuartConfig-&gt;txFifoWatermark = 0; lpuartConfig-&gt;rxFifoWatermark = 1; lpuartConfig-&gt;rxIdleType = kLPUART_IdleTypeStartBit; lpuartConfig-&gt;rxIdleConfig = kLPUART_IdleCharacter1; lpuartConfig-&gt;enableTx = false; lpuartConfig-&gt;enableRx = false;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to a configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the default configuration structure.</p>
<p>This function initializes the LPUART configuration structure to a default value. The default values are: lpuartConfig-&gt;baudRate_Bps = 115200U; lpuartConfig-&gt;parityMode = kLPUART_ParityDisabled; lpuartConfig-&gt;dataBitsCount = kLPUART_EightDataBits; lpuartConfig-&gt;isMsb = false; lpuartConfig-&gt;stopBitCount = kLPUART_OneStopBit; lpuartConfig-&gt;txFifoWatermark = 0; lpuartConfig-&gt;rxFifoWatermark = 1; lpuartConfig-&gt;rxIdleType = kLPUART_IdleTypeStartBit; lpuartConfig-&gt;rxIdleConfig = kLPUART_IdleCharacter1; lpuartConfig-&gt;enableTx = false; lpuartConfig-&gt;enableRx = false;</p>
<p>param config Pointer to a configuration structure. </p>

</div>
</div>
<a id="ga172b524bae8bacc6dc95d9daf82c97b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga172b524bae8bacc6dc95d9daf82c97b5">&#9670;&nbsp;</a></span>LPUART_GetEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPUART_GetEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets enabled LPUART interrupts. </p>
<p>This function gets the enabled LPUART interrupts. The enabled interrupts are returned as the logical OR value of the enumerators <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>. To check a specific interrupt enable status, compare the return value with enumerators in <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>. For example, to check whether the TX empty interrupt is enabled: </p><div class="fragment"><div class="line">uint32_t enabledInterrupts = <a class="code" href="group__lpuart__driver.html#ga172b524bae8bacc6dc95d9daf82c97b5">LPUART_GetEnabledInterrupts</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__lpuart__driver.html#gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c">kLPUART_TxDataRegEmptyInterruptEnable</a> &amp; enabledInterrupts)</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lpuart__driver_html_ga172b524bae8bacc6dc95d9daf82c97b5"><div class="ttname"><a href="group__lpuart__driver.html#ga172b524bae8bacc6dc95d9daf82c97b5">LPUART_GetEnabledInterrupts</a></div><div class="ttdeci">uint32_t LPUART_GetEnabledInterrupts(LPUART_Type *base)</div><div class="ttdoc">Gets enabled LPUART interrupts.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:763</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LPUART interrupt flags which are logical OR of the enumerators in <a class="el" href="group__lpuart__driver.html#ga199a157d391291a9d003bf23954f9603">_lpuart_interrupt_enable</a>.</dd></dl>
<p>brief Gets enabled LPUART interrupts.</p>
<p>This function gets the enabled LPUART interrupts. The enabled interrupts are returned as the logical OR value of the enumerators ref _lpuart_interrupt_enable. To check a specific interrupt enable status, compare the return value with enumerators in ref _lpuart_interrupt_enable. For example, to check whether the TX empty interrupt is enabled: code uint32_t enabledInterrupts = LPUART_GetEnabledInterrupts(LPUART1);</p>
<p>if (kLPUART_TxDataRegEmptyInterruptEnable &amp; enabledInterrupts) { ... } endcode</p>
<p>param base LPUART peripheral base address. return LPUART interrupt flags which are logical OR of the enumerators in ref _lpuart_interrupt_enable. </p>

</div>
</div>
<a id="gaaf4c8ce1f1730cdbf094931033d9b52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf4c8ce1f1730cdbf094931033d9b52c">&#9670;&nbsp;</a></span>LPUART_GetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPUART_GetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the LPUART instance from peripheral base address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LPUART instance.</dd></dl>
<p>brief Get the LPUART instance from peripheral base address.</p>
<p>param base LPUART peripheral base address. return LPUART instance. </p>

</div>
</div>
<a id="gab83db963591b116f90daf3e24118cb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab83db963591b116f90daf3e24118cb09">&#9670;&nbsp;</a></span>LPUART_GetStatusFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LPUART_GetStatusFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets LPUART status flags. </p>
<p>This function gets all LPUART status flags. The flags are returned as the logical OR value of the enumerators <a class="el" href="group__lpuart__driver.html#ga24bb7ca3f894fe5ff55b9f38bec16c89">_lpuart_flags</a>. To check for a specific status, compare the return value with enumerators in the <a class="el" href="group__lpuart__driver.html#ga24bb7ca3f894fe5ff55b9f38bec16c89">_lpuart_flags</a>. For example, to check whether the TX is empty: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a">kLPUART_TxDataRegEmptyFlag</a> &amp; <a class="code" href="group__lpuart__driver.html#gab83db963591b116f90daf3e24118cb09">LPUART_GetStatusFlags</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>))</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="agroup__lpuart__driver_html_gab83db963591b116f90daf3e24118cb09"><div class="ttname"><a href="group__lpuart__driver.html#gab83db963591b116f90daf3e24118cb09">LPUART_GetStatusFlags</a></div><div class="ttdeci">uint32_t LPUART_GetStatusFlags(LPUART_Type *base)</div><div class="ttdoc">Gets LPUART status flags.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:792</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a"><div class="ttname"><a href="group__lpuart__driver.html#gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a">kLPUART_TxDataRegEmptyFlag</a></div><div class="ttdeci">@ kLPUART_TxDataRegEmptyFlag</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:151</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LPUART status flags which are ORed by the enumerators in the _lpuart_flags.</dd></dl>
<p>brief Gets LPUART status flags.</p>
<p>This function gets all LPUART status flags. The flags are returned as the logical OR value of the enumerators ref _lpuart_flags. To check for a specific status, compare the return value with enumerators in the ref _lpuart_flags. For example, to check whether the TX is empty: code if (kLPUART_TxDataRegEmptyFlag &amp; LPUART_GetStatusFlags(LPUART1)) { ... } endcode</p>
<p>param base LPUART peripheral base address. return LPUART status flags which are ORed by the enumerators in the _lpuart_flags. </p>

</div>
</div>
<a id="ga26ce3e5d63d8dd5d317a83f22af9682c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ce3e5d63d8dd5d317a83f22af9682c">&#9670;&nbsp;</a></span>LPUART_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__lpuart__driver.html#ga8386269b3452ae51c17c941d79ec7a39">lpuart_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an LPUART instance with the user configuration structure and the peripheral clock. </p>
<p>This function configures the LPUART module with user-defined settings. Call the <a class="el" href="group__lpuart__driver.html#ga95dfe3c3886692f1fe32023d59708440" title="Gets the default configuration structure.">LPUART_GetDefaultConfig()</a> function to configure the configuration structure and get the default configuration. The example below shows how to use this API to configure the LPUART. </p><div class="fragment"><div class="line"><a class="code" href="struct__lpuart__config.html">lpuart_config_t</a> lpuartConfig;</div>
<div class="line">lpuartConfig.<a class="code" href="group__lpuart__driver.html#gae83107a96ce0e34e791aac795a4d04e4">baudRate_Bps</a> = 115200U;</div>
<div class="line">lpuartConfig.<a class="code" href="group__lpuart__driver.html#ga4571e45bcd0dc5e23ef6c9491f415636">parityMode</a> = <a class="code" href="group__lpuart__driver.html#gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a">kLPUART_ParityDisabled</a>;</div>
<div class="line">lpuartConfig.<a class="code" href="group__lpuart__driver.html#gaf78b1ec3d4ad983717c0ddb6fc90a7c3">dataBitsCount</a> = <a class="code" href="group__lpuart__driver.html#gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899">kLPUART_EightDataBits</a>;</div>
<div class="line">lpuartConfig.<a class="code" href="group__lpuart__driver.html#ga0b1bc6d9fd6be7a792e3f06ef9801ceb">isMsb</a> = <span class="keyword">false</span>;</div>
<div class="line">lpuartConfig.stopBitCount = <a class="code" href="group__lpuart__driver.html#ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901">kLPUART_OneStopBit</a>;</div>
<div class="line">lpuartConfig.txFifoWatermark = 0;</div>
<div class="line">lpuartConfig.rxFifoWatermark = 1;</div>
<div class="line"><a class="code" href="group__lpuart__driver.html#ga26ce3e5d63d8dd5d317a83f22af9682c">LPUART_Init</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>, &amp;lpuartConfig, 20000000U);</div>
<div class="ttc" id="agroup__lpuart__driver_html_ga0b1bc6d9fd6be7a792e3f06ef9801ceb"><div class="ttname"><a href="group__lpuart__driver.html#ga0b1bc6d9fd6be7a792e3f06ef9801ceb">_lpuart_config::isMsb</a></div><div class="ttdeci">bool isMsb</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:199</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_ga26ce3e5d63d8dd5d317a83f22af9682c"><div class="ttname"><a href="group__lpuart__driver.html#ga26ce3e5d63d8dd5d317a83f22af9682c">LPUART_Init</a></div><div class="ttdeci">status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)</div><div class="ttdoc">Initializes an LPUART instance with the user configuration structure and the peripheral clock.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:243</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_ga4571e45bcd0dc5e23ef6c9491f415636"><div class="ttname"><a href="group__lpuart__driver.html#ga4571e45bcd0dc5e23ef6c9491f415636">_lpuart_config::parityMode</a></div><div class="ttdeci">lpuart_parity_mode_t parityMode</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:197</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gae83107a96ce0e34e791aac795a4d04e4"><div class="ttname"><a href="group__lpuart__driver.html#gae83107a96ce0e34e791aac795a4d04e4">_lpuart_config::baudRate_Bps</a></div><div class="ttdeci">uint32_t baudRate_Bps</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:196</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gaf78b1ec3d4ad983717c0ddb6fc90a7c3"><div class="ttname"><a href="group__lpuart__driver.html#gaf78b1ec3d4ad983717c0ddb6fc90a7c3">_lpuart_config::dataBitsCount</a></div><div class="ttdeci">lpuart_data_bits_t dataBitsCount</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:198</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a"><div class="ttname"><a href="group__lpuart__driver.html#gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a">kLPUART_ParityDisabled</a></div><div class="ttdeci">@ kLPUART_ParityDisabled</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:59</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899"><div class="ttname"><a href="group__lpuart__driver.html#gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899">kLPUART_EightDataBits</a></div><div class="ttdeci">@ kLPUART_EightDataBits</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:67</div></div>
<div class="ttc" id="agroup__lpuart__driver_html_ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901"><div class="ttname"><a href="group__lpuart__driver.html#ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901">kLPUART_OneStopBit</a></div><div class="ttdeci">@ kLPUART_OneStopBit</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:76</div></div>
<div class="ttc" id="astruct__lpuart__config_html"><div class="ttname"><a href="struct__lpuart__config.html">_lpuart_config</a></div><div class="ttdoc">LPUART configuration structure.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.h:195</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to a user-defined configuration structure. </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>LPUART clock source frequency in HZ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_LPUART_BaudrateNotSupport</td><td>Baudrate is not support in current clock source. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>LPUART initialize succeed</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes an LPUART instance with the user configuration structure and the peripheral clock.</p>
<p>This function configures the LPUART module with user-defined settings. Call the <a class="el" href="group__lpuart__driver.html#ga95dfe3c3886692f1fe32023d59708440" title="Gets the default configuration structure.">LPUART_GetDefaultConfig()</a> function to configure the configuration structure and get the default configuration. The example below shows how to use this API to configure the LPUART. code lpuart_config_t lpuartConfig; lpuartConfig.baudRate_Bps = 115200U; lpuartConfig.parityMode = kLPUART_ParityDisabled; lpuartConfig.dataBitsCount = kLPUART_EightDataBits; lpuartConfig.isMsb = false; lpuartConfig.stopBitCount = kLPUART_OneStopBit; lpuartConfig.txFifoWatermark = 0; lpuartConfig.rxFifoWatermark = 1; LPUART_Init(LPUART1, &amp;lpuartConfig, 20000000U); endcode</p>
<p>param base LPUART peripheral base address. param config Pointer to a user-defined configuration structure. param srcClock_Hz LPUART clock source frequency in HZ. retval kStatus_LPUART_BaudrateNotSupport Baudrate is not support in current clock source. retval kStatus_Success LPUART initialize succeed </p>

</div>
</div>
<a id="gae76aba14dbfe94124082785e2c0ecd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76aba14dbfe94124082785e2c0ecd9d">&#9670;&nbsp;</a></span>LPUART_ReadBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_ReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the receiver data register using a blocking method. </p>
<p>This function polls the receiver register, waits for the receiver register full or receiver FIFO has data, and reads data from the TX register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">data</td><td>Start address of the buffer to store the received data. </td></tr>
    <tr><td class="paramname">length</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_LPUART_RxHardwareOverrun</td><td>Receiver overrun happened while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_NoiseError</td><td>Noise error happened while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_FramingError</td><td>Framing error happened while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_ParityError</td><td>Parity error happened while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_Timeout</td><td>Transmission timed out and was aborted. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully received all data.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Reads the receiver data register using a blocking method.</p>
<p>This function polls the receiver register, waits for the receiver register full or receiver FIFO has data, and reads data from the TX register.</p>
<p>param base LPUART peripheral base address. param data Start address of the buffer to store the received data. param length Size of the buffer. retval kStatus_LPUART_RxHardwareOverrun Receiver overrun happened while receiving data. retval kStatus_LPUART_NoiseError Noise error happened while receiving data. retval kStatus_LPUART_FramingError Framing error happened while receiving data. retval kStatus_LPUART_ParityError Parity error happened while receiving data. retval kStatus_LPUART_Timeout Transmission timed out and was aborted. retval kStatus_Success Successfully received all data. </p>

</div>
</div>
<a id="ga85a7dbe15a9f822847791cebe75d5394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a7dbe15a9f822847791cebe75d5394">&#9670;&nbsp;</a></span>LPUART_SendAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_SendAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit an address frame in 9-bit data mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">address</td><td>LPUART slave address.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Transmit an address frame in 9-bit data mode.</p>
<p>param base LPUART peripheral base address. param address LPUART slave address. </p>

</div>
</div>
<a id="gaf03d9292f8b4cb6e9748cb0bc1db7577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf03d9292f8b4cb6e9748cb0bc1db7577">&#9670;&nbsp;</a></span>LPUART_SetBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate_Bps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the LPUART instance baudrate. </p>
<p>This function configures the LPUART module baudrate. This function is used to update the LPUART module baudrate after the LPUART module is initialized by the LPUART_Init. </p><div class="fragment"><div class="line"><a class="code" href="group__lpuart__driver.html#gaf03d9292f8b4cb6e9748cb0bc1db7577">LPUART_SetBaudRate</a>(<a class="code" href="group__LPUART__Peripheral__Access__Layer.html#ga73eb37d103f4e4f2d18ec3d3f5208ab9">LPUART1</a>, 115200U, 20000000U);</div>
<div class="ttc" id="agroup__lpuart__driver_html_gaf03d9292f8b4cb6e9748cb0bc1db7577"><div class="ttname"><a href="group__lpuart__driver.html#gaf03d9292f8b4cb6e9748cb0bc1db7577">LPUART_SetBaudRate</a></div><div class="ttdeci">status_t LPUART_SetBaudRate(LPUART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)</div><div class="ttdoc">Sets the LPUART instance baudrate.</div><div class="ttdef"><b>Definition:</b> fsl_lpuart.c:564</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">baudRate_Bps</td><td>LPUART baudrate to be set. </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>LPUART clock source frequency in HZ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_LPUART_BaudrateNotSupport</td><td>Baudrate is not supported in the current clock source. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Set baudrate succeeded.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets the LPUART instance baudrate.</p>
<p>This function configures the LPUART module baudrate. This function is used to update the LPUART module baudrate after the LPUART module is initialized by the LPUART_Init. code LPUART_SetBaudRate(LPUART1, 115200U, 20000000U); endcode</p>
<p>param base LPUART peripheral base address. param baudRate_Bps LPUART baudrate to be set. param srcClock_Hz LPUART clock source frequency in HZ. retval kStatus_LPUART_BaudrateNotSupport Baudrate is not supported in the current clock source. retval kStatus_Success Set baudrate succeeded. </p>

</div>
</div>
<a id="ga4950fa0f3835992251c109f655a3ca7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4950fa0f3835992251c109f655a3ca7d">&#9670;&nbsp;</a></span>LPUART_TransferAbortReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferAbortReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the interrupt-driven data receiving. </p>
<p>This function aborts the interrupt-driven data receiving. The user can get the remainBytes to find out how many bytes not received yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the interrupt-driven data receiving.</p>
<p>This function aborts the interrupt-driven data receiving. The user can get the remainBytes to find out how many bytes not received yet.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. </p>

</div>
</div>
<a id="ga6dfe9efe9656e126c70ee79fa03f2be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dfe9efe9656e126c70ee79fa03f2be3">&#9670;&nbsp;</a></span>LPUART_TransferAbortSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferAbortSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the interrupt-driven data transmit. </p>
<p>This function aborts the interrupt driven data sending. The user can get the remainBtyes to find out how many bytes are not sent out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the interrupt-driven data transmit.</p>
<p>This function aborts the interrupt driven data sending. The user can get the remainBtyes to find out how many bytes are not sent out.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. </p>

</div>
</div>
<a id="ga10eae12610523a624c1016882f8dba5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10eae12610523a624c1016882f8dba5f">&#9670;&nbsp;</a></span>LPUART_TransferCreateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferCreateHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lpuart__driver.html#ga558e0c23c05831e446708a3935f36332">lpuart_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the LPUART handle. </p>
<p>This function initializes the LPUART handle, which can be used for other LPUART transactional APIs. Usually, for a specified LPUART instance, call this API once to get the initialized handle.</p>
<p>The LPUART driver supports the "background" receiving, which means that user can set up an RX ring buffer optionally. Data received is stored into the ring buffer even when the user doesn't call the <a class="el" href="group__lpuart__driver.html#ga8bdb584704ce7955004751e32627f918" title="Receives a buffer of data using the interrupt method.">LPUART_TransferReceiveNonBlocking()</a> API. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly. The ring buffer is disabled if passing NULL as <code>ringBuffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">callback</td><td>Callback function. </td></tr>
    <tr><td class="paramname">userData</td><td>User data.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the LPUART handle.</p>
<p>This function initializes the LPUART handle, which can be used for other LPUART transactional APIs. Usually, for a specified LPUART instance, call this API once to get the initialized handle.</p>
<p>The LPUART driver supports the "background" receiving, which means that user can set up an RX ring buffer optionally. Data received is stored into the ring buffer even when the user doesn't call the <a class="el" href="group__lpuart__driver.html#ga8bdb584704ce7955004751e32627f918" title="Receives a buffer of data using the interrupt method.">LPUART_TransferReceiveNonBlocking()</a> API. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly. The ring buffer is disabled if passing NULL as p ringBuffer.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param callback Callback function. param userData User data. </p>

</div>
</div>
<a id="gabfcdc658c463e9e7523cc60c5e8f9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfcdc658c463e9e7523cc60c5e8f9672">&#9670;&nbsp;</a></span>LPUART_TransferGetReceiveCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_TransferGetReceiveCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bytes that have been received. </p>
<p>This function gets the number of bytes that have been received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">count</td><td>Receive bytes count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_NoTransferInProgress</td><td>No receive in progress. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Parameter is invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Get successfully through the parameter <code>count</code>;</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the number of bytes that have been received.</p>
<p>This function gets the number of bytes that have been received.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param count Receive bytes count. retval kStatus_NoTransferInProgress No receive in progress. retval kStatus_InvalidArgument Parameter is invalid. retval kStatus_Success Get successfully through the parameter <code>count</code>; </p>

</div>
</div>
<a id="ga550523d301acfa413919c2f979228bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550523d301acfa413919c2f979228bcc">&#9670;&nbsp;</a></span>LPUART_TransferGetRxRingBufferLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t LPUART_TransferGetRxRingBufferLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of received data in RX ring buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of received data in RX ring buffer.</dd></dl>
<p>brief Get the length of received data in RX ring buffer.</p>
<p>userData handle LPUART handle pointer. return Length of received data in RX ring buffer. </p>

</div>
</div>
<a id="gad80d2469dce0de9361e731e4cefde9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad80d2469dce0de9361e731e4cefde9fd">&#9670;&nbsp;</a></span>LPUART_TransferGetSendCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_TransferGetSendCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bytes that have been sent out to bus. </p>
<p>This function gets the number of bytes that have been sent out to bus by an interrupt method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">count</td><td>Send bytes count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_NoTransferInProgress</td><td>No send in progress. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Parameter is invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Get successfully through the parameter <code>count</code>;</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the number of bytes that have been sent out to bus.</p>
<p>This function gets the number of bytes that have been sent out to bus by an interrupt method.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param count Send bytes count. retval kStatus_NoTransferInProgress No send in progress. retval kStatus_InvalidArgument Parameter is invalid. retval kStatus_Success Get successfully through the parameter <code>count</code>; </p>

</div>
</div>
<a id="ga21345340b5d8f90df6bb64acab0f870f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21345340b5d8f90df6bb64acab0f870f">&#9670;&nbsp;</a></span>LPUART_TransferHandleErrorIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferHandleErrorIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART Error IRQ handle function. </p>
<p>This function handles the LPUART error IRQ request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief LPUART Error IRQ handle function.</p>
<p>This function handles the LPUART error IRQ request.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. </p>

</div>
</div>
<a id="gac81ce3c490d7185ab7e2d97963ae077e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81ce3c490d7185ab7e2d97963ae077e">&#9670;&nbsp;</a></span>LPUART_TransferHandleIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferHandleIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LPUART IRQ handle function. </p>
<p>This function handles the LPUART transmit and receive IRQ request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief LPUART IRQ handle function.</p>
<p>This function handles the LPUART transmit and receive IRQ request.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. </p>

</div>
</div>
<a id="ga8bdb584704ce7955004751e32627f918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdb584704ce7955004751e32627f918">&#9670;&nbsp;</a></span>LPUART_TransferReceiveNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_TransferReceiveNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37">lpuart_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>receivedBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a buffer of data using the interrupt method. </p>
<p>This function receives data using an interrupt method. This is a non-blocking function which returns without waiting to ensure that all data are received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter <code>receivedBytes</code> shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough for read, the receive request is saved by the LPUART driver. When the new data arrives, the receive request is serviced first. When all data is received, the LPUART driver notifies the upper layer through a callback function and passes a status parameter kStatus_UART_RxIdle. For example, the upper layer needs 10 bytes but there are only 5 bytes in ring buffer. The 5 bytes are copied to xfer-&gt;data, which returns with the parameter <code>receivedBytes</code> set to 5. For the remaining 5 bytes, the newly arrived data is saved from xfer-&gt;data[5]. When 5 bytes are received, the LPUART driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to xfer-&gt;data. When all data is received, the upper layer is notified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">xfer</td><td>LPUART transfer structure, see uart_transfer_t. </td></tr>
    <tr><td class="paramname">receivedBytes</td><td>Bytes received from the ring buffer directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully queue the transfer into the transmit queue. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_RxBusy</td><td>Previous receive request is not finished. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Invalid argument.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Receives a buffer of data using the interrupt method.</p>
<p>This function receives data using an interrupt method. This is a non-blocking function which returns without waiting to ensure that all data are received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter p receivedBytes shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough for read, the receive request is saved by the LPUART driver. When the new data arrives, the receive request is serviced first. When all data is received, the LPUART driver notifies the upper layer through a callback function and passes a status parameter ref kStatus_UART_RxIdle. For example, the upper layer needs 10 bytes but there are only 5 bytes in ring buffer. The 5 bytes are copied to xfer-&gt;data, which returns with the parameter p receivedBytes set to 5. For the remaining 5 bytes, the newly arrived data is saved from xfer-&gt;data[5]. When 5 bytes are received, the LPUART driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to xfer-&gt;data. When all data is received, the upper layer is notified.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param xfer LPUART transfer structure, see #uart_transfer_t. param receivedBytes Bytes received from the ring buffer directly. retval kStatus_Success Successfully queue the transfer into the transmit queue. retval kStatus_LPUART_RxBusy Previous receive request is not finished. retval kStatus_InvalidArgument Invalid argument. </p>

</div>
</div>
<a id="gafba986c473e5935131e63cb882cf26ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafba986c473e5935131e63cb882cf26ff">&#9670;&nbsp;</a></span>LPUART_TransferSendNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_TransferSendNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37">lpuart_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a buffer of data using the interrupt method. </p>
<p>This function send data using an interrupt method. This is a non-blocking function, which returns directly without waiting for all data written to the transmitter register. When all data is written to the TX register in the ISR, the LPUART driver calls the callback function and passes the <a class="el" href="group__lpuart__driver.html#ggab04a0655cd1e3bcac5e8f48c18df1a57a079c6d0957d121ce7cd95cf97487dfbb">kStatus_LPUART_TxIdle</a> as status parameter.</p>
<dl class="section note"><dt>Note</dt><dd>The kStatus_LPUART_TxIdle is passed to the upper layer when all data are written to the TX register. However, there is no check to ensure that all the data sent out. Before disabling the TX, check the kLPUART_TransmissionCompleteFlag to ensure that the transmit is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">xfer</td><td>LPUART transfer structure, see <a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37" title="LPUART transfer structure.">lpuart_transfer_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully start the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_LPUART_TxBusy</td><td>Previous transmission still not finished, data not all written to the TX register. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Invalid argument.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Transmits a buffer of data using the interrupt method.</p>
<p>This function send data using an interrupt method. This is a non-blocking function, which returns directly without waiting for all data written to the transmitter register. When all data is written to the TX register in the ISR, the LPUART driver calls the callback function and passes the ref kStatus_LPUART_TxIdle as status parameter.</p>
<p>note The kStatus_LPUART_TxIdle is passed to the upper layer when all data are written to the TX register. However, there is no check to ensure that all the data sent out. Before disabling the TX, check the kLPUART_TransmissionCompleteFlag to ensure that the transmit is finished.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param xfer LPUART transfer structure, see <a class="el" href="group__lpuart__driver.html#ga3aa4668de3b88738217a6dad33354b37" title="LPUART transfer structure.">lpuart_transfer_t</a>. retval kStatus_Success Successfully start the data transmission. retval kStatus_LPUART_TxBusy Previous transmission still not finished, data not all written to the TX register. retval kStatus_InvalidArgument Invalid argument. </p>

</div>
</div>
<a id="ga5257b77491042af5913a8d91c66318e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5257b77491042af5913a8d91c66318e1">&#9670;&nbsp;</a></span>LPUART_TransferStartRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferStartRingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ringBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the RX ring buffer. </p>
<p>This function sets up the RX ring buffer to a specific UART handle.</p>
<p>When the RX ring buffer is used, data received is stored into the ring buffer even when the user doesn't call the UART_TransferReceiveNonBlocking() API. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly.</p>
<dl class="section note"><dt>Note</dt><dd>When using RX ring buffer, one byte is reserved for internal use. In other words, if <code>ringBufferSize</code> is 32, then only 31 bytes are used for saving data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer. </td></tr>
    <tr><td class="paramname">ringBuffer</td><td>Start address of ring buffer for background receiving. Pass NULL to disable the ring buffer. </td></tr>
    <tr><td class="paramname">ringBufferSize</td><td>size of the ring buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets up the RX ring buffer.</p>
<p>This function sets up the RX ring buffer to a specific UART handle.</p>
<p>When the RX ring buffer is used, data received is stored into the ring buffer even when the user doesn't call the UART_TransferReceiveNonBlocking() API. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly.</p>
<p>note When using RX ring buffer, one byte is reserved for internal use. In other words, if p ringBufferSize is 32, then only 31 bytes are used for saving data.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. param ringBuffer Start address of ring buffer for background receiving. Pass NULL to disable the ring buffer. param ringBufferSize size of the ring buffer. </p>

</div>
</div>
<a id="gad6a230a664808592aab153ea20e3d60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6a230a664808592aab153ea20e3d60b">&#9670;&nbsp;</a></span>LPUART_TransferStopRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPUART_TransferStopRingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__lpuart__handle.html">lpuart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the background transfer and uninstalls the ring buffer. </p>
<p>This function aborts the background transfer and uninstalls the ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>LPUART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the background transfer and uninstalls the ring buffer.</p>
<p>This function aborts the background transfer and uninstalls the ring buffer.</p>
<p>param base LPUART peripheral base address. param handle LPUART handle pointer. </p>

</div>
</div>
<a id="ga2699958de62ff4832f95bc2dd8c454a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2699958de62ff4832f95bc2dd8c454a5">&#9670;&nbsp;</a></span>LPUART_WriteBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> LPUART_WriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structLPUART__Type.html">LPUART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the transmitter register using a blocking method. </p>
<p>This function polls the transmitter register, first waits for the register to be empty or TX FIFO to have room, and writes data to the transmitter buffer, then waits for the dat to be sent out to the bus.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>LPUART peripheral base address. </td></tr>
    <tr><td class="paramname">data</td><td>Start address of the data to write. </td></tr>
    <tr><td class="paramname">length</td><td>Size of the data to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_LPUART_Timeout</td><td>Transmission timed out and was aborted. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully wrote all data.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Writes to the transmitter register using a blocking method.</p>
<p>This function polls the transmitter register, first waits for the register to be empty or TX FIFO to have room, and writes data to the transmitter buffer, then waits for the data to be sent out to bus.</p>
<p>param base LPUART peripheral base address. param data Start address of the data to write. param length Size of the data to write. retval kStatus_LPUART_Timeout Transmission timed out and was aborted. retval kStatus_Success Successfully wrote all data. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae83107a96ce0e34e791aac795a4d04e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae83107a96ce0e34e791aac795a4d04e4">&#9670;&nbsp;</a></span>baudRate_Bps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t _lpuart_config::baudRate_Bps</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LPUART baud rate <br  />
 </p>

</div>
</div>
<a id="gab50459b72a63e6b30c8ed3671a8af981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab50459b72a63e6b30c8ed3671a8af981">&#9670;&nbsp;</a></span>callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lpuart__driver.html#ga558e0c23c05831e446708a3935f36332">lpuart_transfer_callback_t</a> _lpuart_handle::callback</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function. </p>

</div>
</div>
<a id="ga5f0e6f0be1311cf09de693c9a9ff9c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0e6f0be1311cf09de693c9a9ff9c70">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* _lpuart_transfer::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The buffer of data to be transfer. </p>

</div>
</div>
<a id="gaf78b1ec3d4ad983717c0ddb6fc90a7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf78b1ec3d4ad983717c0ddb6fc90a7c3">&#9670;&nbsp;</a></span>dataBitsCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lpuart__driver.html#ga6785b5dcafe473d18fd40d490251c5eb">lpuart_data_bits_t</a> _lpuart_config::dataBitsCount</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data bits count, eight (default), seven </p>

</div>
</div>
<a id="gaaa76dae4246c582cb20524f7c3b1be8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa76dae4246c582cb20524f7c3b1be8b">&#9670;&nbsp;</a></span>dataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _lpuart_transfer::dataSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The byte count to be transfer. </p>

</div>
</div>
<a id="gab5249f5987bbb04eb5ae5e9cfb6e5358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5249f5987bbb04eb5ae5e9cfb6e5358">&#9670;&nbsp;</a></span>enableRx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lpuart_config::enableRx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable RX </p>

</div>
</div>
<a id="gab9558be2149e5a5730eff2d7bb1fdb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9558be2149e5a5730eff2d7bb1fdb28">&#9670;&nbsp;</a></span>enableTx</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lpuart_config::enableTx</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable TX </p>

</div>
</div>
<a id="ga0b1bc6d9fd6be7a792e3f06ef9801ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b1bc6d9fd6be7a792e3f06ef9801ceb">&#9670;&nbsp;</a></span>isMsb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lpuart_config::isMsb</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data bits order, LSB (default), MSB </p>

</div>
</div>
<a id="ga4571e45bcd0dc5e23ef6c9491f415636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4571e45bcd0dc5e23ef6c9491f415636">&#9670;&nbsp;</a></span>parityMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lpuart__driver.html#gaade003e399c40357cf787b87e39083a1">lpuart_parity_mode_t</a> _lpuart_config::parityMode</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parity mode, disabled (default), even, odd </p>

</div>
</div>
<a id="ga22f222c17b99b9528dabcc7bc2b2a54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f222c17b99b9528dabcc7bc2b2a54b">&#9670;&nbsp;</a></span>rxData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* volatile _lpuart_handle::rxData</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Address of remaining data to receive. </p>

</div>
</div>
<a id="gacc516aa43ddb7eeec9288820af1ecd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc516aa43ddb7eeec9288820af1ecd89">&#9670;&nbsp;</a></span>rxDataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t _lpuart_handle::rxDataSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the remaining data to receive. </p>

</div>
</div>
<a id="gae577a09ca8d3b9eb73f90d308d842e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae577a09ca8d3b9eb73f90d308d842e79">&#9670;&nbsp;</a></span>rxDataSizeAll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _lpuart_handle::rxDataSizeAll</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the data to receive. </p>

</div>
</div>
<a id="gab5389e158519dd57c804a10ef5dc3c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5389e158519dd57c804a10ef5dc3c00">&#9670;&nbsp;</a></span>rxIdleConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lpuart__driver.html#gaaf5c727d57d2e3dcf413d6dcdb3e74c1">lpuart_idle_config_t</a> _lpuart_config::rxIdleConfig</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX IDLE configuration. </p>

</div>
</div>
<a id="ga45ac9d819675f5cae10bb7234a0f4342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ac9d819675f5cae10bb7234a0f4342">&#9670;&nbsp;</a></span>rxIdleType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__lpuart__driver.html#ga42eaf9d7f780b53a6e974743122eebb0">lpuart_idle_type_select_t</a> _lpuart_config::rxIdleType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX IDLE type. </p>

</div>
</div>
<a id="ga1100410b5924efeb1a55ec14e15d39f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1100410b5924efeb1a55ec14e15d39f1">&#9670;&nbsp;</a></span>rxRingBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* _lpuart_handle::rxRingBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start address of the receiver ring buffer. </p>

</div>
</div>
<a id="ga20aadb739214ab07e45cb9226132192e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20aadb739214ab07e45cb9226132192e">&#9670;&nbsp;</a></span>rxRingBufferHead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t _lpuart_handle::rxRingBufferHead</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index for the driver to store received data into ring buffer. </p>

</div>
</div>
<a id="ga08db8e558ba77d8c5ece4f60822f60c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08db8e558ba77d8c5ece4f60822f60c3">&#9670;&nbsp;</a></span>rxRingBufferSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _lpuart_handle::rxRingBufferSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the ring buffer. </p>

</div>
</div>
<a id="ga2777d723511750a6b39f5169135a909f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2777d723511750a6b39f5169135a909f">&#9670;&nbsp;</a></span>rxRingBufferTail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t _lpuart_handle::rxRingBufferTail</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Index for the user to get data from the ring buffer. </p>

</div>
</div>
<a id="gac113a769dffef4a25e7ecac12c412893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac113a769dffef4a25e7ecac12c412893">&#9670;&nbsp;</a></span>rxState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t _lpuart_handle::rxState</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX transfer state. </p>

</div>
</div>
<a id="ga5ee65bd1ba63882989180cb0b8904d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee65bd1ba63882989180cb0b8904d6a">&#9670;&nbsp;</a></span>txData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* volatile _lpuart_handle::txData</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Address of remaining data to send. </p>

</div>
</div>
<a id="ga9c7df82f52174be9a8d21f26eba8b63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7df82f52174be9a8d21f26eba8b63f">&#9670;&nbsp;</a></span>txDataSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile size_t _lpuart_handle::txDataSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the remaining data to send. </p>

</div>
</div>
<a id="ga2535ea3d50a0e1ebc64ef678792ca143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2535ea3d50a0e1ebc64ef678792ca143">&#9670;&nbsp;</a></span>txDataSizeAll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t _lpuart_handle::txDataSizeAll</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the data to send out. </p>

</div>
</div>
<a id="ga15865b470edd53b37c580981c718f559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15865b470edd53b37c580981c718f559">&#9670;&nbsp;</a></span>txState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint8_t _lpuart_handle::txState</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX transfer state. </p>

</div>
</div>
<a id="gae2ac81d3089f6b9b2772708b49502441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2ac81d3089f6b9b2772708b49502441">&#9670;&nbsp;</a></span>userData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* _lpuart_handle::userData</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LPUART callback function parameter. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
